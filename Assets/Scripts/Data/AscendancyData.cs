using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// ScriptableObject defining an Ascendancy class (advanced specialization).
/// Each base class has 3 Ascendancy options that grant permanent upgrades.
/// </summary>
[CreateAssetMenu(fileName = "NewAscendancy", menuName = "Dexiled/Ascendancy Data", order = 3)]
public class AscendancyData : ScriptableObject
{
    [Header("Basic Info")]
    [Tooltip("Ascendancy name (e.g., 'Occultist', 'Elementalist', 'Necromancer')")]
    public string ascendancyName = "";
    
    [Tooltip("Which base class this Ascendancy belongs to (e.g., 'Witch', 'Marauder')")]
    public string baseClass = "";
    
    [Tooltip("Short tagline/subtitle (e.g., 'Master of Curses', 'Elemental Savant')")]
    public string tagline = "";
    
    [Header("Visual Assets")]
    [Tooltip("Splash art for this Ascendancy (displayed on character creation screen)")]
    public Sprite splashArt;
    
    [Tooltip("Icon for this Ascendancy (for UI lists, small displays)")]
    public Sprite icon;
    
    [Tooltip("Background color/theme for this Ascendancy")]
    public Color themeColor = Color.white;
    
    [Header("Description")]
    [Tooltip("Full description of what this Ascendancy does")]
    [TextArea(3, 6)]
    public string description = "";
    
    [Tooltip("Playstyle keywords (e.g., 'Damage over Time', 'Summoner', 'Tank')")]
    public List<string> playstyleKeywords = new List<string>();
    
    [Header("Core Mechanic")]
    [Tooltip("Name of the core mechanic (e.g., 'Crumble', 'Tolerance', 'Battle Rhythm')")]
    public string coreMechanicName = "";
    
    [Tooltip("Detailed explanation of how the core mechanic works")]
    [TextArea(3, 5)]
    public string coreMechanicDescription = "";
    
    [Header("Passive Abilities")]
    [Tooltip("LEGACY: All passives in one list (use branches instead for better organization)")]
    public List<AscendancyPassive> passiveAbilities = new List<AscendancyPassive>();
    
    [Header("Tree Branches (Recommended)")]
    [Tooltip("Start node (auto-unlocked, center of tree)")]
    public AscendancyPassive startNode;
    
    [Tooltip("Branches extending from the start node (or from split nodes if sourceNodeName is set)")]
    public List<AscendancyBranch> branches = new List<AscendancyBranch>();
    
    [Tooltip("Split nodes: Nodes that spawn multiple branches. Key = node name, Value = list of branch names that spawn from it.")]
    public List<AscendancySplitNode> splitNodes = new List<AscendancySplitNode>();
    
    [Tooltip("Use branches for tree layout (recommended over flat passive list)")]
    public bool useBranchSystem = true;

    [Header("Floating Nodes (Advanced)")]
    [Tooltip("Standalone nodes that bridge existing passives (ideal for cross-branch links)")]
    public List<AscendancyFloatingNode> floatingNodes = new List<AscendancyFloatingNode>();
    
    [Header("Signature Card")]
    [Tooltip("The unique card unlocked by this Ascendancy")]
    public AscendancySignatureCard signatureCard;
    
    [Header("Unlock Requirements")]
    [Tooltip("Character level required to unlock this Ascendancy")]
    public int requiredLevel = 15;
    
    [Tooltip("Quest or challenge required to unlock (optional)")]
    public string unlockRequirement = "";
    
    [Header("Progression")]
    [Tooltip("Number of Ascendancy points this class can earn (typically 8)")]
    public int maxAscendancyPoints = 8;
    
    [Header("Tree Structure")]
    [Tooltip("Position of the Start node in the tree (0,0 = center)")]
    public Vector2 startNodePosition = Vector2.zero;
    
    [Tooltip("Define branching paths in the tree (optional, for advanced layouts)")]
    public List<AscendancyTreePath> treePaths = new List<AscendancyTreePath>();
    
    [Tooltip("Use automatic path generation (Start -> Minor -> Major pattern)")]
    public bool useAutoGeneratedPaths = true;
    
    [Tooltip("Number of branches (typically 2)")]
    public int numberOfBranches = 2;
    
    /// <summary>
    /// Get all nodes (combines start + all branches)
    /// </summary>
    public List<AscendancyPassive> GetAllNodes()
    {
        List<AscendancyPassive> allNodes = new List<AscendancyPassive>();
        
        if (useBranchSystem)
        {
            // Use branch system
            if (startNode != null)
                allNodes.Add(startNode);
            
            if (branches != null)
            {
                foreach (var branch in branches)
                {
                    if (branch != null && branch.branchNodes != null)
                        allNodes.AddRange(branch.branchNodes);
                }
            }

            if (floatingNodes != null)
            {
                foreach (var floating in floatingNodes)
                {
                    if (floating != null && floating.node != null)
                        allNodes.Add(floating.node);
                }
            }
        }
        else
        {
            // Use legacy flat list
            if (passiveAbilities != null)
                allNodes.AddRange(passiveAbilities);

            if (floatingNodes != null)
            {
                foreach (var floating in floatingNodes)
                {
                    if (floating != null && floating.node != null)
                        allNodes.Add(floating.node);
                }
            }
        }
        
        return allNodes;
    }
    
    /// <summary>
    /// Get a formatted string of all passive abilities
    /// </summary>
    public string GetPassivesSummary()
    {
        var allNodes = GetAllNodes();
        
        if (allNodes.Count == 0)
            return "No passive abilities defined.";
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        foreach (var passive in allNodes)
        {
            if (passive != null)
                sb.AppendLine($"• [{passive.nodeType}] {passive.name}: {passive.description}");
        }
        return sb.ToString();
    }
    
    /// <summary>
    /// Get number of unlockable passive abilities
    /// </summary>
    public int GetPassiveCount()
    {
        return GetAllNodes().Count;
    }
    
    /// <summary>
    /// Auto-generate tree structure (call this in Inspector or code)
    /// </summary>
    public void GenerateTreeStructure()
    {
        if (!useBranchSystem || branches == null) return;
        if (startNode == null)
        {
            Debug.LogWarning("[AscendancyData] Cannot generate tree structure - no start node!");
            return;
        }
        
        // Set start node position (customizable per Ascendancy)
        startNode.treePosition = startNodePosition;
        startNode.prerequisitePassives.Clear();
        startNode.nodeType = AscendancyNodeType.Start; // Ensure it's marked as Start
        startNode.pointCost = 0;
        startNode.unlockedByDefault = true;
        startNode.requireAllPrerequisites = true;
        
        // Generate branches in phases:
        // Phase 1: Branches from start node (sourceNodeName empty or matches start)
        // Phase 2: Branches from split nodes (sourceNodeName matches a split node)
        
        // Phase 1: Start node branches
        foreach (var branch in branches)
        {
            if (branch != null && string.IsNullOrEmpty(branch.sourceNodeName))
            {
                branch.GenerateBranchStructure(startNode.name, startNodePosition, this);
            }
        }
        
        // Phase 1.5: Handle merge nodes (nodes that are the target of multiple branches)
        HandleMergeNodes();
        
        // Phase 2: Split node branches (generate after all nodes are positioned)
        foreach (var splitNode in splitNodes)
        {
            if (splitNode == null || string.IsNullOrEmpty(splitNode.nodeName))
                continue;
                
            AscendancyPassive splitPassive = FindPassiveByName(splitNode.nodeName);
            if (splitPassive == null)
            {
                Debug.LogWarning($"[AscendancyData] Split node '{splitNode.nodeName}' not found!");
                continue;
            }
            
            // Generate branches that start from this split node
            for (int i = 0; i < splitNode.branchNames.Count; i++)
            {
                string branchName = splitNode.branchNames[i];
                var branch = branches.Find(b => b != null && b.branchName == branchName);
                if (branch != null && branch.sourceNodeName == splitNode.nodeName)
                {
                    // Apply angle from split node if provided
                    if (splitNode.branchAngles != null && i < splitNode.branchAngles.Count)
                    {
                        branch.branchAngle = splitNode.branchAngles[i];
                    }
                    else if (splitNode.branchNames.Count > 1)
                    {
                        // Auto-space branches evenly if no angles provided
                        float angleStep = 360f / splitNode.branchNames.Count;
                        branch.branchAngle = angleStep * i;
                    }
                    
                    branch.GenerateBranchStructure(startNode.name, startNodePosition, this);
                }
            }
        }

        // Generate floating node layout after branches (so referenced positions exist)
        GenerateFloatingNodesStructure();
        
        Debug.Log($"[AscendancyData] Generated tree structure for {ascendancyName}: {branches.Count} branches, Start at {startNode.treePosition}");
    }
    
    /// <summary>
    /// Handle merge nodes: nodes that are the last node in multiple branches.
    /// These nodes should have prerequisites from all incoming branches.
    /// </summary>
    void HandleMergeNodes()
    {
        if (branches == null) return;
        
        // Find all nodes that appear as the last node in multiple branches
        Dictionary<string, List<string>> mergeNodePrerequisites = new Dictionary<string, List<string>>();
        
        foreach (var branch in branches)
        {
            if (branch == null || branch.branchNodes == null || branch.branchNodes.Count == 0)
                continue;
                
            // Get the last node in this branch
            AscendancyPassive lastNode = branch.branchNodes[branch.branchNodes.Count - 1];
            if (lastNode == null) continue;
            
            // Get the second-to-last node (the prerequisite)
            string prerequisiteName = null;
            if (branch.branchNodes.Count > 1)
            {
                prerequisiteName = branch.branchNodes[branch.branchNodes.Count - 2].name;
            }
            else if (!string.IsNullOrEmpty(branch.sourceNodeName))
            {
                prerequisiteName = branch.sourceNodeName;
            }
            else
            {
                prerequisiteName = startNode.name;
            }
            
            if (!string.IsNullOrEmpty(prerequisiteName))
            {
                if (!mergeNodePrerequisites.ContainsKey(lastNode.name))
                {
                    mergeNodePrerequisites[lastNode.name] = new List<string>();
                }
                
                if (!mergeNodePrerequisites[lastNode.name].Contains(prerequisiteName))
                {
                    mergeNodePrerequisites[lastNode.name].Add(prerequisiteName);
                }
            }
        }
        
        // Apply merge node prerequisites (nodes with multiple incoming branches)
        foreach (var kvp in mergeNodePrerequisites)
        {
            if (kvp.Value.Count > 1) // Multiple branches merge into this node
            {
                AscendancyPassive mergeNode = FindPassiveByName(kvp.Key);
                if (mergeNode != null)
                {
                    // Preserve existing prerequisites and add merge prerequisites
                    foreach (string prereq in kvp.Value)
                    {
                        if (!mergeNode.prerequisitePassives.Contains(prereq))
                        {
                            mergeNode.prerequisitePassives.Add(prereq);
                        }
                    }
                    mergeNode.requireAllPrerequisites = false; // Any prerequisite unlocks it
                    
                    Debug.Log($"[AscendancyData] Merge node '{mergeNode.name}' requires any of: {string.Join(", ", mergeNode.prerequisitePassives)}");
                }
            }
        }
    }

    /// <summary>
    /// Position and configure floating nodes that bridge branches
    /// </summary>
    void GenerateFloatingNodesStructure()
    {
        if (floatingNodes == null || floatingNodes.Count == 0)
            return;

        foreach (var floating in floatingNodes)
        {
            if (floating == null || floating.node == null)
                continue;

            AscendancyPassive floatingNode = floating.node;

            // Floating nodes act like minor nodes in presentation
            floatingNode.nodeType = AscendancyNodeType.Minor;
            floatingNode.requireAllPrerequisites = false;
            floatingNode.unlockedByDefault = false;

            // Resolve referenced nodes
            AscendancyPassive first = FindPassiveByName(floating.firstNodeName);
            AscendancyPassive second = FindPassiveByName(floating.secondNodeName);

            // Initialize prerequisites list if null
            if (floatingNode.prerequisitePassives == null)
            {
                floatingNode.prerequisitePassives = new List<string>();
            }

            // PRESERVE manually added prerequisites instead of clearing them
            // Only add the two major nodes if they're not already in the list
            bool hasAnyPrerequisite = floatingNode.prerequisitePassives.Count > 0;

            if (first != null)
            {
                if (!floatingNode.prerequisitePassives.Contains(first.name))
                {
                    floatingNode.prerequisitePassives.Add(first.name);
                    hasAnyPrerequisite = true;
                }
            }
            else if (!string.IsNullOrEmpty(floating.firstNodeName))
            {
                Debug.LogWarning($"[AscendancyData] Floating node '{floatingNode.name}' could not find first node: {floating.firstNodeName}");
            }

            if (second != null)
            {
                if (!floatingNode.prerequisitePassives.Contains(second.name))
                {
                    floatingNode.prerequisitePassives.Add(second.name);
                    hasAnyPrerequisite = true;
                }
            }
            else if (!string.IsNullOrEmpty(floating.secondNodeName))
            {
                Debug.LogWarning($"[AscendancyData] Floating node '{floatingNode.name}' could not find second node: {floating.secondNodeName}");
            }

            // Add floating node as prerequisite to the two major nodes (reverse direction)
            if (first != null)
            {
                if (first.prerequisitePassives == null)
                {
                    first.prerequisitePassives = new List<string>();
                }
                if (!first.prerequisitePassives.Contains(floatingNode.name))
                {
                    first.prerequisitePassives.Add(floatingNode.name);
                    Debug.Log($"[AscendancyData] Added floating node '{floatingNode.name}' as prerequisite to '{first.name}'");
                }
            }

            if (second != null)
            {
                if (second.prerequisitePassives == null)
                {
                    second.prerequisitePassives = new List<string>();
                }
                if (!second.prerequisitePassives.Contains(floatingNode.name))
                {
                    second.prerequisitePassives.Add(floatingNode.name);
                    Debug.Log($"[AscendancyData] Added floating node '{floatingNode.name}' as prerequisite to '{second.name}'");
                }
            }

            if (!hasAnyPrerequisite)
            {
                Debug.LogWarning($"[AscendancyData] Floating node '{floatingNode.name}' has no valid prerequisites and will be skipped.");
                continue;
            }

            // Base midpoint between the referenced nodes
            Vector2 midpoint;

            if (first != null && second != null)
            {
                Vector2 firstPos = first.treePosition;
                Vector2 secondPos = second.treePosition;
                Vector2 line = secondPos - firstPos;
                float length = line.magnitude;
                Vector2 direction = length > 0.001f ? (line / length) : Vector2.right;

                float bias = Mathf.Clamp(floating.midpointBias, -0.5f, 0.5f) * length;
                float multiplierOffset = (floating.distanceMultiplier - 1f) * (length * 0.5f);

                Vector2 center = (firstPos + secondPos) * 0.5f;
                midpoint = center + direction * (bias + multiplierOffset);
            }
            else if (first != null)
            {
                midpoint = first.treePosition;
            }
            else
            {
                midpoint = second != null ? second.treePosition : startNodePosition;
            }

            // Apply distance multiplier (push away/toward center of referenced line)
            // Apply perpendicular offset if requested
            if (first != null && second != null && floating.perpendicularOffset != 0f)
            {
                Vector2 line = (second.treePosition - first.treePosition).normalized;
                Vector2 perpendicular = new Vector2(-line.y, line.x);
                midpoint += perpendicular * floating.perpendicularOffset;
            }

            midpoint += floating.positionOffset;

            floatingNode.treePosition = midpoint;

            if (floating.nodeScaleOverride > 0f)
            {
                floatingNode.nodeScale = floating.nodeScaleOverride;
            }

        }
    }

    public AscendancyPassive FindPassiveByName(string nodeName)
    {
        if (string.IsNullOrEmpty(nodeName))
            return null;

        if (startNode != null && startNode.name == nodeName)
            return startNode;

        if (branches != null)
        {
            foreach (var branch in branches)
            {
                if (branch == null || branch.branchNodes == null)
                    continue;

                foreach (var node in branch.branchNodes)
                {
                    if (node != null && node.name == nodeName)
                        return node;
                }
            }
        }

        if (floatingNodes != null)
        {
            foreach (var floating in floatingNodes)
            {
                if (floating != null && floating.node != null && floating.node.name == nodeName)
                    return floating.node;
            }
        }

        return null;
    }
    
    /// <summary>
    /// Get all minor nodes
    /// </summary>
    public List<AscendancyPassive> GetMinorNodes()
    {
        if (passiveAbilities == null) return new List<AscendancyPassive>();
        return passiveAbilities.FindAll(p => p.nodeType == AscendancyNodeType.Minor);
    }
    
    /// <summary>
    /// Get all major nodes
    /// </summary>
    public List<AscendancyPassive> GetMajorNodes()
    {
        if (passiveAbilities == null) return new List<AscendancyPassive>();
        return passiveAbilities.FindAll(p => p.nodeType == AscendancyNodeType.Major);
    }
    
    /// <summary>
    /// Get the start node
    /// </summary>
    public AscendancyPassive GetStartNode()
    {
        if (passiveAbilities == null) return null;
        return passiveAbilities.Find(p => p.nodeType == AscendancyNodeType.Start);
    }
    
    /// <summary>
    /// Get a formatted string of playstyle keywords
    /// </summary>
    public string GetKeywordsString()
    {
        if (playstyleKeywords == null || playstyleKeywords.Count == 0)
            return "";
        
        return string.Join(" • ", playstyleKeywords);
    }
    
    /// <summary>
    /// Get all nodes in a specific group (for mutually exclusive node validation)
    /// </summary>
    public List<AscendancyPassive> GetNodesInGroup(string groupId)
    {
        if (string.IsNullOrEmpty(groupId))
            return new List<AscendancyPassive>();
        
        List<AscendancyPassive> nodesInGroup = new List<AscendancyPassive>();
        List<AscendancyPassive> allNodes = GetAllNodes();
        
        foreach (var node in allNodes)
        {
            if (node != null && !string.IsNullOrEmpty(node.nodeGroup) && node.nodeGroup == groupId)
            {
                nodesInGroup.Add(node);
            }
        }
        
        return nodesInGroup;
    }
    
    /// <summary>
    /// Check if any node in the same group is already unlocked
    /// </summary>
    public bool IsAnyNodeInGroupUnlocked(string groupId, CharacterAscendancyProgress progression)
    {
        if (string.IsNullOrEmpty(groupId) || progression == null)
            return false;
        
        List<AscendancyPassive> nodesInGroup = GetNodesInGroup(groupId);
        
        foreach (var node in nodesInGroup)
        {
            if (progression.IsPassiveUnlocked(node.name))
            {
                return true;
            }
        }
        
        return false;
    }
}

/// <summary>
/// Node type for Ascendancy tree structure
/// </summary>
public enum AscendancyNodeType
{
    Start,    // Starting node (auto-unlocked)
    Minor,    // Small passive (1 point, minor bonuses)
    Major     // Notable passive (1 point, major bonuses)
}

/// <summary>
/// Represents an individual passive ability that can be unlocked
/// </summary>
[System.Serializable]
public class AscendancyPassive
{
    [Header("Basic Info")]
    [Tooltip("Name of the passive ability")]
    public string name = "";
    
    [Tooltip("Node type (Start, Minor, or Major)")]
    public AscendancyNodeType nodeType = AscendancyNodeType.Minor;
    
    [Tooltip("Description of what this passive does")]
    [TextArea(2, 4)]
    public string description = "";
    
    [Header("Visuals")]
    [Tooltip("Icon representing this passive (optional)")]
    public Sprite icon;
    
    [Tooltip("Node size multiplier (Major nodes are typically larger)")]
    public float nodeScale = 1.0f;
    
    [Header("Progression")]
    [Tooltip("Ascendancy point cost to unlock (typically 1)")]
    public int pointCost = 1;
    
    [Tooltip("Is this passive unlocked by default when Ascendancy is chosen?")]
    public bool unlockedByDefault = false;
    
    [Header("Tree Structure")]
    [Tooltip("Other passives that must be unlocked first (connects nodes)")]
    public List<string> prerequisitePassives = new List<string>();

    [Tooltip("If true, ALL prerequisites must be unlocked. If false, any one is sufficient.")]
    public bool requireAllPrerequisites = true;
    
    [Tooltip("Position in the tree (for manual layout control)")]
    public Vector2 treePosition = Vector2.zero;
    
    [Header("Node Grouping (Mutually Exclusive)")]
    [Tooltip("Group ID for mutually exclusive nodes. Nodes with the same group ID can only have ONE unlocked at a time. Leave empty for no grouping.")]
    public string nodeGroup = "";
    
    [Header("Choice Node (Sub-Node Selection)")]
    [Tooltip("If true, this is a choice node that displays sub-nodes in a circle around it. Clicking a sub-node applies its sprite to this main node.")]
    public bool isChoiceNode = false;
    
    [Tooltip("List of sub-nodes that circle around this choice node. Each sub-node represents a different choice/option.")]
    public List<AscendancySubNode> subNodes = new List<AscendancySubNode>();
    
    [Tooltip("Radius of the circle for sub-nodes (distance from main node center)")]
    public float subNodeRadius = 100f;
    
    [Tooltip("Currently selected sub-node index (-1 = no selection, returns to sub-node display)")]
    public int selectedSubNodeIndex = -1;
}

/// <summary>
/// Represents a sub-node option for a choice node.
/// Sub-nodes circle around the main choice node and can be selected.
/// </summary>
[System.Serializable]
public class AscendancySubNode
{
    [Header("Sub-Node Info")]
    [Tooltip("Name of this sub-node option")]
    public string name = "";
    
    [Tooltip("Icon/sprite for this sub-node (applied to main node when selected)")]
    public Sprite icon;
    
    [Tooltip("Description of what this choice does")]
    [TextArea(2, 4)]
    public string description = "";
    
    [Tooltip("Point cost to select this sub-node (typically 0, as main node cost covers it)")]
    public int pointCost = 0;
    
    [Tooltip("Angle offset for positioning this sub-node around the main node (0-360 degrees)")]
    [Range(0f, 360f)]
    public float angleOffset = 0f;
}

[System.Serializable]
public class AscendancyFloatingNode
{
    [Header("Floating Node")] 
    [Tooltip("Passive to spawn between branches")] 
    public AscendancyPassive node;

    [Header("Connections")]
    [Tooltip("Name of the first node this floating node connects to")] 
    public string firstNodeName = "";

    [Tooltip("Name of the second node this floating node connects to")] 
    public string secondNodeName = "";

    [Header("Position Tweaks")]
    [Tooltip("Offset applied after midpoint calculation")] 
    public Vector2 positionOffset = Vector2.zero;

    [Tooltip("Bias along the line towards the second node (-0.5 to 0.5 typical)")] 
    [Range(-0.5f, 0.5f)]
    public float midpointBias = 0f;

    [Tooltip("Scale the distance between the two nodes before positioning (1 = exact midpoint)")] 
    public float distanceMultiplier = 1f;

    [Tooltip("Perpendicular offset from the connecting line (positive = one side, negative = opposite)")] 
    public float perpendicularOffset = 0f;

    [Tooltip("Override for node scale (0 = use node's value)")] 
    public float nodeScaleOverride = 0f;
}

/// <summary>
/// Represents a node that splits into multiple branches.
/// Use this to create structures like: Node -> Branch1, Branch2, Branch3
/// </summary>
[System.Serializable]
public class AscendancySplitNode
{
    [Header("Split Node Info")]
    [Tooltip("Name of the node that splits into multiple branches")]
    public string nodeName = "";
    
    [Tooltip("List of branch names that spawn from this node. Each branch must have sourceNodeName matching this nodeName.")]
    public List<string> branchNames = new List<string>();
    
    [Tooltip("Optional: Angles for each branch (if empty, uses branch's branchAngle). Useful for evenly spacing branches.")]
    public List<float> branchAngles = new List<float>();
}

/// <summary>
/// Represents the signature card unlocked by an Ascendancy
/// </summary>
[System.Serializable]
public class AscendancySignatureCard
{
    [Tooltip("Number of copies added to deck")]
    public int copies = 3;
    
    [Tooltip("Card name")]
    public string cardName = "";
    
    [Tooltip("Card type (Attack, Spell, Guard, Skill)")]
    public string cardType = "Attack";
    
    [Tooltip("Mana cost")]
    public int manaCost = 1;
    
    [Tooltip("Card description/effect")]
    [TextArea(3, 6)]
    public string description = "";
    
    [Tooltip("Reference to actual CardDataExtended (if card exists)")]
    public CardDataExtended cardData;
    
    /// <summary>
    /// Get formatted card info
    /// </summary>
    public string GetCardInfo()
    {
        return $"{copies}x {cardName} ({cardType} - {manaCost} Mana)\n{description}";
    }
}

