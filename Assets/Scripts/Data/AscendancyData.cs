using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// ScriptableObject defining an Ascendancy class (advanced specialization).
/// Each base class has 3 Ascendancy options that grant permanent upgrades.
/// </summary>
[CreateAssetMenu(fileName = "NewAscendancy", menuName = "Dexiled/Ascendancy Data", order = 3)]
public class AscendancyData : ScriptableObject
{
    [Header("Basic Info")]
    [Tooltip("Ascendancy name (e.g., 'Occultist', 'Elementalist', 'Necromancer')")]
    public string ascendancyName = "";
    
    [Tooltip("Which base class this Ascendancy belongs to (e.g., 'Witch', 'Marauder')")]
    public string baseClass = "";
    
    [Tooltip("Short tagline/subtitle (e.g., 'Master of Curses', 'Elemental Savant')")]
    public string tagline = "";
    
    [Header("Visual Assets")]
    [Tooltip("Splash art for this Ascendancy (displayed on character creation screen)")]
    public Sprite splashArt;
    
    [Tooltip("Icon for this Ascendancy (for UI lists, small displays)")]
    public Sprite icon;
    
    [Tooltip("Background color/theme for this Ascendancy")]
    public Color themeColor = Color.white;
    
    [Header("Description")]
    [Tooltip("Full description of what this Ascendancy does")]
    [TextArea(3, 6)]
    public string description = "";
    
    [Tooltip("Playstyle keywords (e.g., 'Damage over Time', 'Summoner', 'Tank')")]
    public List<string> playstyleKeywords = new List<string>();
    
    [Header("Core Mechanic")]
    [Tooltip("Name of the core mechanic (e.g., 'Crumble', 'Tolerance', 'Battle Rhythm')")]
    public string coreMechanicName = "";
    
    [Tooltip("Detailed explanation of how the core mechanic works")]
    [TextArea(3, 5)]
    public string coreMechanicDescription = "";
    
    [Header("Passive Abilities")]
    [Tooltip("LEGACY: All passives in one list (use branches instead for better organization)")]
    public List<AscendancyPassive> passiveAbilities = new List<AscendancyPassive>();
    
    [Header("Tree Branches (Recommended)")]
    [Tooltip("Start node (auto-unlocked, center of tree)")]
    public AscendancyPassive startNode;
    
    [Tooltip("Branches extending from the start node")]
    public List<AscendancyBranch> branches = new List<AscendancyBranch>();
    
    [Tooltip("Use branches for tree layout (recommended over flat passive list)")]
    public bool useBranchSystem = true;

    [Header("Floating Nodes (Advanced)")]
    [Tooltip("Standalone nodes that bridge existing passives (ideal for cross-branch links)")]
    public List<AscendancyFloatingNode> floatingNodes = new List<AscendancyFloatingNode>();
    
    [Header("Signature Card")]
    [Tooltip("The unique card unlocked by this Ascendancy")]
    public AscendancySignatureCard signatureCard;
    
    [Header("Unlock Requirements")]
    [Tooltip("Character level required to unlock this Ascendancy")]
    public int requiredLevel = 15;
    
    [Tooltip("Quest or challenge required to unlock (optional)")]
    public string unlockRequirement = "";
    
    [Header("Progression")]
    [Tooltip("Number of Ascendancy points this class can earn (typically 8)")]
    public int maxAscendancyPoints = 8;
    
    [Header("Tree Structure")]
    [Tooltip("Position of the Start node in the tree (0,0 = center)")]
    public Vector2 startNodePosition = Vector2.zero;
    
    [Tooltip("Define branching paths in the tree (optional, for advanced layouts)")]
    public List<AscendancyTreePath> treePaths = new List<AscendancyTreePath>();
    
    [Tooltip("Use automatic path generation (Start -> Minor -> Major pattern)")]
    public bool useAutoGeneratedPaths = true;
    
    [Tooltip("Number of branches (typically 2)")]
    public int numberOfBranches = 2;
    
    /// <summary>
    /// Get all nodes (combines start + all branches)
    /// </summary>
    public List<AscendancyPassive> GetAllNodes()
    {
        List<AscendancyPassive> allNodes = new List<AscendancyPassive>();
        
        if (useBranchSystem)
        {
            // Use branch system
            if (startNode != null)
                allNodes.Add(startNode);
            
            if (branches != null)
            {
                foreach (var branch in branches)
                {
                    if (branch != null && branch.branchNodes != null)
                        allNodes.AddRange(branch.branchNodes);
                }
            }

            if (floatingNodes != null)
            {
                foreach (var floating in floatingNodes)
                {
                    if (floating != null && floating.node != null)
                        allNodes.Add(floating.node);
                }
            }
        }
        else
        {
            // Use legacy flat list
            if (passiveAbilities != null)
                allNodes.AddRange(passiveAbilities);

            if (floatingNodes != null)
            {
                foreach (var floating in floatingNodes)
                {
                    if (floating != null && floating.node != null)
                        allNodes.Add(floating.node);
                }
            }
        }
        
        return allNodes;
    }
    
    /// <summary>
    /// Get a formatted string of all passive abilities
    /// </summary>
    public string GetPassivesSummary()
    {
        var allNodes = GetAllNodes();
        
        if (allNodes.Count == 0)
            return "No passive abilities defined.";
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        foreach (var passive in allNodes)
        {
            if (passive != null)
                sb.AppendLine($"• [{passive.nodeType}] {passive.name}: {passive.description}");
        }
        return sb.ToString();
    }
    
    /// <summary>
    /// Get number of unlockable passive abilities
    /// </summary>
    public int GetPassiveCount()
    {
        return GetAllNodes().Count;
    }
    
    /// <summary>
    /// Auto-generate tree structure (call this in Inspector or code)
    /// </summary>
    public void GenerateTreeStructure()
    {
        if (!useBranchSystem || branches == null) return;
        if (startNode == null)
        {
            Debug.LogWarning("[AscendancyData] Cannot generate tree structure - no start node!");
            return;
        }
        
        // Set start node position (customizable per Ascendancy)
        startNode.treePosition = startNodePosition;
        startNode.prerequisitePassives.Clear();
        startNode.nodeType = AscendancyNodeType.Start; // Ensure it's marked as Start
        startNode.pointCost = 0;
        startNode.unlockedByDefault = true;
        startNode.requireAllPrerequisites = true;
        
        // Generate each branch
        foreach (var branch in branches)
        {
            if (branch != null)
            {
                branch.GenerateBranchStructure(startNode.name, startNodePosition);
            }
        }

        // Generate floating node layout after branches (so referenced positions exist)
        GenerateFloatingNodesStructure();
        
        Debug.Log($"[AscendancyData] Generated tree structure for {ascendancyName}: {branches.Count} branches, Start at {startNode.treePosition}");
    }

    /// <summary>
    /// Position and configure floating nodes that bridge branches
    /// </summary>
    void GenerateFloatingNodesStructure()
    {
        if (floatingNodes == null || floatingNodes.Count == 0)
            return;

        foreach (var floating in floatingNodes)
        {
            if (floating == null || floating.node == null)
                continue;

            AscendancyPassive floatingNode = floating.node;

            // Floating nodes act like minor nodes in presentation
            floatingNode.nodeType = AscendancyNodeType.Minor;
            floatingNode.requireAllPrerequisites = false;
            floatingNode.unlockedByDefault = false;

            // Resolve referenced nodes
            AscendancyPassive first = FindPassiveByName(floating.firstNodeName);
            AscendancyPassive second = FindPassiveByName(floating.secondNodeName);

            floatingNode.prerequisitePassives.Clear();

            bool hasAnyPrerequisite = false;

            if (first != null)
            {
                floatingNode.prerequisitePassives.Add(first.name);
                hasAnyPrerequisite = true;
            }
            else if (!string.IsNullOrEmpty(floating.firstNodeName))
            {
                Debug.LogWarning($"[AscendancyData] Floating node '{floatingNode.name}' could not find first node: {floating.firstNodeName}");
            }

            if (second != null)
            {
                if (!floatingNode.prerequisitePassives.Contains(second.name))
                    floatingNode.prerequisitePassives.Add(second.name);
                hasAnyPrerequisite = true;
            }
            else if (!string.IsNullOrEmpty(floating.secondNodeName))
            {
                Debug.LogWarning($"[AscendancyData] Floating node '{floatingNode.name}' could not find second node: {floating.secondNodeName}");
            }

            if (!hasAnyPrerequisite)
            {
                Debug.LogWarning($"[AscendancyData] Floating node '{floatingNode.name}' has no valid prerequisites and will be skipped.");
                continue;
            }

            // Base midpoint between the referenced nodes
            Vector2 midpoint;

            if (first != null && second != null)
            {
                Vector2 firstPos = first.treePosition;
                Vector2 secondPos = second.treePosition;
                Vector2 line = secondPos - firstPos;
                float length = line.magnitude;
                Vector2 direction = length > 0.001f ? (line / length) : Vector2.right;

                float bias = Mathf.Clamp(floating.midpointBias, -0.5f, 0.5f) * length;
                float multiplierOffset = (floating.distanceMultiplier - 1f) * (length * 0.5f);

                Vector2 center = (firstPos + secondPos) * 0.5f;
                midpoint = center + direction * (bias + multiplierOffset);
            }
            else if (first != null)
            {
                midpoint = first.treePosition;
            }
            else
            {
                midpoint = second != null ? second.treePosition : startNodePosition;
            }

            // Apply distance multiplier (push away/toward center of referenced line)
            // Apply perpendicular offset if requested
            if (first != null && second != null && floating.perpendicularOffset != 0f)
            {
                Vector2 line = (second.treePosition - first.treePosition).normalized;
                Vector2 perpendicular = new Vector2(-line.y, line.x);
                midpoint += perpendicular * floating.perpendicularOffset;
            }

            midpoint += floating.positionOffset;

            floatingNode.treePosition = midpoint;

            if (floating.nodeScaleOverride > 0f)
            {
                floatingNode.nodeScale = floating.nodeScaleOverride;
            }

        }
    }

    AscendancyPassive FindPassiveByName(string nodeName)
    {
        if (string.IsNullOrEmpty(nodeName))
            return null;

        if (startNode != null && startNode.name == nodeName)
            return startNode;

        if (branches != null)
        {
            foreach (var branch in branches)
            {
                if (branch == null || branch.branchNodes == null)
                    continue;

                foreach (var node in branch.branchNodes)
                {
                    if (node != null && node.name == nodeName)
                        return node;
                }
            }
        }

        if (floatingNodes != null)
        {
            foreach (var floating in floatingNodes)
            {
                if (floating != null && floating.node != null && floating.node.name == nodeName)
                    return floating.node;
            }
        }

        return null;
    }
    
    /// <summary>
    /// Get all minor nodes
    /// </summary>
    public List<AscendancyPassive> GetMinorNodes()
    {
        if (passiveAbilities == null) return new List<AscendancyPassive>();
        return passiveAbilities.FindAll(p => p.nodeType == AscendancyNodeType.Minor);
    }
    
    /// <summary>
    /// Get all major nodes
    /// </summary>
    public List<AscendancyPassive> GetMajorNodes()
    {
        if (passiveAbilities == null) return new List<AscendancyPassive>();
        return passiveAbilities.FindAll(p => p.nodeType == AscendancyNodeType.Major);
    }
    
    /// <summary>
    /// Get the start node
    /// </summary>
    public AscendancyPassive GetStartNode()
    {
        if (passiveAbilities == null) return null;
        return passiveAbilities.Find(p => p.nodeType == AscendancyNodeType.Start);
    }
    
    /// <summary>
    /// Get a formatted string of playstyle keywords
    /// </summary>
    public string GetKeywordsString()
    {
        if (playstyleKeywords == null || playstyleKeywords.Count == 0)
            return "";
        
        return string.Join(" • ", playstyleKeywords);
    }
}

/// <summary>
/// Node type for Ascendancy tree structure
/// </summary>
public enum AscendancyNodeType
{
    Start,    // Starting node (auto-unlocked)
    Minor,    // Small passive (1 point, minor bonuses)
    Major     // Notable passive (1 point, major bonuses)
}

/// <summary>
/// Represents an individual passive ability that can be unlocked
/// </summary>
[System.Serializable]
public class AscendancyPassive
{
    [Header("Basic Info")]
    [Tooltip("Name of the passive ability")]
    public string name = "";
    
    [Tooltip("Node type (Start, Minor, or Major)")]
    public AscendancyNodeType nodeType = AscendancyNodeType.Minor;
    
    [Tooltip("Description of what this passive does")]
    [TextArea(2, 4)]
    public string description = "";
    
    [Header("Visuals")]
    [Tooltip("Icon representing this passive (optional)")]
    public Sprite icon;
    
    [Tooltip("Node size multiplier (Major nodes are typically larger)")]
    public float nodeScale = 1.0f;
    
    [Header("Progression")]
    [Tooltip("Ascendancy point cost to unlock (typically 1)")]
    public int pointCost = 1;
    
    [Tooltip("Is this passive unlocked by default when Ascendancy is chosen?")]
    public bool unlockedByDefault = false;
    
    [Header("Tree Structure")]
    [Tooltip("Other passives that must be unlocked first (connects nodes)")]
    public List<string> prerequisitePassives = new List<string>();

    [Tooltip("If true, ALL prerequisites must be unlocked. If false, any one is sufficient.")]
    public bool requireAllPrerequisites = true;
    
    [Tooltip("Position in the tree (for manual layout control)")]
    public Vector2 treePosition = Vector2.zero;
}

[System.Serializable]
public class AscendancyFloatingNode
{
    [Header("Floating Node")] 
    [Tooltip("Passive to spawn between branches")] 
    public AscendancyPassive node;

    [Header("Connections")]
    [Tooltip("Name of the first node this floating node connects to")] 
    public string firstNodeName = "";

    [Tooltip("Name of the second node this floating node connects to")] 
    public string secondNodeName = "";

    [Header("Position Tweaks")]
    [Tooltip("Offset applied after midpoint calculation")] 
    public Vector2 positionOffset = Vector2.zero;

    [Tooltip("Bias along the line towards the second node (-0.5 to 0.5 typical)")] 
    [Range(-0.5f, 0.5f)]
    public float midpointBias = 0f;

    [Tooltip("Scale the distance between the two nodes before positioning (1 = exact midpoint)")] 
    public float distanceMultiplier = 1f;

    [Tooltip("Perpendicular offset from the connecting line (positive = one side, negative = opposite)")] 
    public float perpendicularOffset = 0f;

    [Tooltip("Override for node scale (0 = use node's value)")] 
    public float nodeScaleOverride = 0f;
}

/// <summary>
/// Represents the signature card unlocked by an Ascendancy
/// </summary>
[System.Serializable]
public class AscendancySignatureCard
{
    [Tooltip("Number of copies added to deck")]
    public int copies = 3;
    
    [Tooltip("Card name")]
    public string cardName = "";
    
    [Tooltip("Card type (Attack, Spell, Guard, Skill)")]
    public string cardType = "Attack";
    
    [Tooltip("Mana cost")]
    public int manaCost = 1;
    
    [Tooltip("Card description/effect")]
    [TextArea(3, 6)]
    public string description = "";
    
    [Tooltip("Reference to actual CardDataExtended (if card exists)")]
    public CardDataExtended cardData;
    
    /// <summary>
    /// Get formatted card info
    /// </summary>
    public string GetCardInfo()
    {
        return $"{copies}x {cardName} ({cardType} - {manaCost} Mana)\n{description}";
    }
}

